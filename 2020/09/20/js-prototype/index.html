<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
   
  <meta name="keywords" content="minjeekim, front-end, develop, frontend, blog" />
   
  <meta name="description" content="MINJEE KIM&#39;S FRONT-END DEVELOP LOG" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <meta property="og:type" content="website">
  <meta property="og:title" content="MJAEDOT">
  <meta property="og:description" content="FRONT-END DEVELOP LOG">
  <meta property="og:image" content="http://mjae404.github.io/images/open_graph_image.jpg">
  <meta property="og:url" content="http://mjae404.github.io">
  <!-- <meta name="naver-site-verification" content="22bb573d69cc09bdcc7adf4f44a7eeb4e77bb3f3"/> -->
  <title>
    JS 프로토타입 |  404 Not Found
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/css/style.css">

  
<script src="/js/pace.min.js"></script>

<link rel="alternate" href="/atom.xml" title="404 Not Found" type="application/atom+xml">
</head>

</html>

<body>
  <div id="app">
    <div class="content" role="main">
      <section class="outer">
  <article id="post-js-prototype" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  JS 프로토타입
</h1>
  

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/09/20/js-prototype/" class="article-date">
  <time datetime="2020-09-20T13:28:03.000Z" itemprop="datePublished">2020-09-20</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaScript/">JavaScript</a>
  </div>

      
    </div>
    

    

    <div class="article-entry" itemprop="articleBody">
      


      

      
      <p><strong>자바스크립트</strong> 는 명령형(Imperative), 함수형(Functional), 프로토타입 기반(Prototype-based) 객체지향 프로그래밍(OOP, Object Oriented Programming)을 지원하는 프로그래밍 언어다.</p>
<a id="more"></a>

<h2 id="객체지향-프로그래밍"><a href="#객체지향-프로그래밍" class="headerlink" title="객체지향 프로그래밍"></a>객체지향 프로그래밍</h2><ul>
<li>객체지향 프로그래밍은 객체의 상태(state)를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작(behavior)을 하나의 논리적인 단위로 묶어 생각한다.</li>
<li><strong>객체</strong>: 상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조. 각각의 객체는 고유의 기능을 갖는 독립적인 부품이라고 볼 수 있지만, 다르 객체와도 관계성을 가질 수 있다.</li>
<li><strong>속성(attribute, property)</strong>: 속성을 통해 어떠한 사물이나 개념을 구체화</li>
<li><strong>추상화(abstraction)</strong>: 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려 내어 표현하는 것</li>
</ul>
<h2 id="상속과-프로토타입"><a href="#상속과-프로토타입" class="headerlink" title="상속과 프로토타입"></a>상속과 프로토타입</h2><ul>
<li><strong>상속(Inheritance)</strong>: 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것</li>
<li> 자바스크립트는 <strong>프로토타입(prototype)을 기반으로 상속을 구현</strong> 한다.</li>
<li>생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현해두면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현없이 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.</li>
</ul>
<h2 id="프로토타입-객체"><a href="#프로토타입-객체" class="headerlink" title="프로토타입 객체"></a>프로토타입 객체</h2><ul>
<li>모든 객체는<code>[[Prototype]]</code>이라는 내부 슬롯을 갖는다.</li>
<li>모든 객체는 하나의 프로토타입을 갖는다. 프로토타입은 <code>null</code>이거나 객체이다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. 즉, 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다.</li>
</ul>
<h3 id="proto-접근자-프로퍼티"><a href="#proto-접근자-프로퍼티" class="headerlink" title="__proto__ 접근자 프로퍼티"></a><code>__proto__</code> 접근자 프로퍼티</h3><p>모든 객체는 <code>__proto__</code> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 <code>[[Prototype]]</code> 내부 슬롯에 접근할 수 있다.</p>
<p><em>1. <code>__proto__</code>는 접근자 프로퍼티이다.</em></p>
<ul>
<li><code>[[Prototype]]</code> 내부 슬롯에 직접 접근할 수 없기 때문에 <code>__prototype</code> 접근자 프로퍼티를 통해 간접적으로 접근한다.</li>
<li><code>Object.prototype</code>의 프로퍼티인 <code>__proto__</code> 접근자 프로퍼티는 <code>getter</code>/<code>setter</code> 함수라고 부르는 접근자 함수를 통해 <code>[[Prototype]]</code> 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당한다.</li>
<li><code>__proto__</code> 접근자 프로퍼티를 통해 <strong><u>프로토타입에 접근</u></strong> 하면 내부적으로 <code>__proto__</code> 접근자 프로퍼티의 <code>getter</code> 함수인 <code>get __proto__</code>가 호출</li>
<li> <code>__proto__</code> 접근자 프로퍼티를 통해 <strong><u>새로운 프로토타입을 할당</u></strong> 하면 <code>__proto__</code> 접근자 프로퍼티의 <code>setter</code> 함수인 <code>set __proto__</code>가 호출</li>
</ul>
<p><em>2. <code>__proto__</code> 접근자 프로퍼티는 상속을 통해 사용된다.</em></p>
<ul>
<li><code>__proto__</code> 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 <code>Object.prototype</code>의 프로퍼티이다.</li>
<li>모든 객체는 상속을 통해 <code>Object.prototype.__proto__</code> 접근자 프로퍼티를 사용할 수 있다.</li>
</ul>
<p><em>3. <code>__proto__</code> 접근자를 통해 프로토타입에 접근하는 이유</em></p>
<ul>
<li>상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함이다.</li>
<li>프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. (프로퍼티 검색 방향이 한쪽 방향으로만 흘러가야 한다.)</li>
<li>순환 참조(circular reference)적인 프로토타입 체인이 만들어지면 프로토타입 체인 종점이 존재하지 않기 때문에 프로토타입 체인에서 프로퍼티를 검색할 때 무한 루프에 빠진다.</li>
</ul>
<p><em>4. <code>__proto__</code> 접근자 프로퍼티를 코드내에서 직접 사용하는 것은 추천하지 않는다.</em></p>
<ul>
<li><code> Object.prototype</code>을 상속받지 않는 객체를 생성할 수도 있어서 모든 객체가 <code>__proto__</code> 접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문이다.</li>
<li> <code>__proto__</code> 접근자 프로퍼티 대신 프로토타입의 참조를 취득할 경우는 <code>Object.getPrototypeOf</code> 메소드를, 프로토타입을 교체하는 경우는 <code>Object.setPrototypeOf</code> 메소드를 사용하는 것을 권장한다.</li>
</ul>
<h3 id="함수-객체의-prototype-프로퍼티"><a href="#함수-객체의-prototype-프로퍼티" class="headerlink" title="함수 객체의 prototype 프로퍼티"></a>함수 객체의 <code>prototype</code> 프로퍼티</h3><ul>
<li>함수 객체는 <code>__proto__</code> 접근자 프로퍼티 이외에 <code>prototype</code> 프로퍼티도 소유한다. 함수 객체의 <code>prototype</code> 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다.</li>
<li><code>prototype</code> 프로퍼티는 <strong>함수 객체만이 소유하는 프로퍼티</strong> 이다. 일반 객체에는 <code>prototype</code> 프로퍼티가 없다.</li>
<li>생성자 함수가 아닌 일반 함수도  <code>prototype</code> 프로퍼티를 소유하지만 객체를 생성하지 않는 일반 함수의 <code>prototype</code> 프로퍼티는 아무런 의미가 없다.</li>
<li>모든 객체가 가지고 있는(<code>Object.prototype</code>로부터 상속받은) <code>__proto__</code> 접근자 프로퍼티와 함수 객체만이 가지고 있는 <code>prototype</code> 프로퍼티는 동일한 프로토타입을 가리키지만 <strong>이들 프로퍼티를 사용하는 주체가 다르다.</strong><table>
<thead>
<tr>
<th>구분</th>
<th>소유</th>
<th>값</th>
<th>사용 주체</th>
<th>사용 목적</th>
</tr>
</thead>
<tbody><tr>
<td><code>__proto__</code> 접근자 프로퍼티</td>
<td>모든 객체</td>
<td>프로토타입의 참조</td>
<td>모든 객체</td>
<td>모든 객체가 상속을 위해 자신의 프로토타입에 접근</td>
</tr>
<tr>
<td><code>prototype</code> 프로퍼티</td>
<td>함수 객체</td>
<td>프로토타입의 참조</td>
<td>생성자 함수</td>
<td>생성자 함수가 자신이 생성할 객체(인스턴스)의 프로토타입을 할당</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="프로토타입의-constructor-프로퍼티와-생성자-함수"><a href="#프로토타입의-constructor-프로퍼티와-생성자-함수" class="headerlink" title="프로토타입의 constructor 프로퍼티와 생성자 함수"></a>프로토타입의 constructor 프로퍼티와 생성자 함수</h3><ul>
<li>모든 프로토타입은 <code>constructor</code> 프로퍼티를 갖는다.</li>
<li><code>constructor</code> 프로퍼티는 <code>prototype</code> 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다.</li>
</ul>
<h2 id="리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입"><a href="#리터럴-표기법에-의해-생성된-객체의-생성자-함수와-프로토타입" class="headerlink" title="리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입"></a>리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입</h2><ul>
<li>프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍(pair)으로 존재한다.</li>
<li>명시적으로 <code>new</code> 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않는 객체 생성 방식도 존재한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 객체 리터럴</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수 리터럴</span></span><br><span class="line"><span class="keyword">const</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123; <span class="keyword">return</span> a + b; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 배열 리터럴</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 정규표현식 리터럴</span></span><br><span class="line"><span class="keyword">const</span> regexr = <span class="regexp">/is/ig</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>리터럴 표기법</th>
<th>생성자 함수</th>
<th>프로토 타입</th>
</tr>
</thead>
<tbody><tr>
<td>객체 리터럴</td>
<td>Object</td>
<td>Object.protptype</td>
</tr>
<tr>
<td>함수 리터럴</td>
<td>Function</td>
<td>Function.prototype</td>
</tr>
<tr>
<td>배열 리터럴</td>
<td>Array</td>
<td>Array.prototype</td>
</tr>
<tr>
<td>정규 표현식 리터럴</td>
<td>RegExp</td>
<td>RegExp.protptype</td>
</tr>
</tbody></table>
<h2 id="프로토타입의-생성-시점"><a href="#프로토타입의-생성-시점" class="headerlink" title="프로토타입의 생성 시점"></a>프로토타입의 생성 시점</h2><p>객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있다.</p>
<blockquote>
<p><strong>생성자 함수</strong><br>사용자가 직접 정의한 <strong>사용자 정의 생성자 함수</strong> 와 자바스크립트가 기본 제공하는 <strong>빌트인 생성자 함수</strong> 로 구분</p>
</blockquote>
<h3 id="사용자-정의-생성자-함수와-프로토타입-생성-시점"><a href="#사용자-정의-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="사용자 정의 생성자 함수와 프로토타입 생성 시점"></a>사용자 정의 생성자 함수와 프로토타입 생성 시점</h3><p>빌트인 생성자 함수가 아닌 <strong>사용자 정의 생성자 함수</strong> 는 자신이 평가되어 함수 객체로 생성되는 시점에 프로토타입도 더불어 생성되며 <strong>생성된 프로토타입의 프로토타입은 언제나 <code>Object.prototype</code></strong> 이다.</p>
<h3 id="빌트인-생성자-함수와-프로토타입-생성-시점"><a href="#빌트인-생성자-함수와-프로토타입-생성-시점" class="headerlink" title="빌트인 생성자 함수와 프로토타입 생성 시점"></a>빌트인 생성자 함수와 프로토타입 생성 시점</h3><p>빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다. <strong>모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성</strong> 된다. 전역 객체는 누구보다도 먼저 생성된다. 이때 빌트인 생성자 함수와 더불어 프로토타입이 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 <code>prototype</code> 프로퍼티에 바인딩된다.</p>
<blockquote>
<p><strong>전역 객체(Global Object)</strong><br>전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체이다. 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 <code>window</code>, 서버 사이드 환경(Node.js)에서는 <code>global</code> 객체를 의미한다.</p>
</blockquote>
<h2 id="객체-생성-방식과-프로토타입의-결정"><a href="#객체-생성-방식과-프로토타입의-결정" class="headerlink" title="객체 생성 방식과 프로토타입의 결정"></a>객체 생성 방식과 프로토타입의 결정</h2><p>각각의 방식 마다 세부적인 객체 생성 방식의 차이는 있으나 <strong>추상 연산 <code>ObjectCreate</code>에 의해 생성된다는 공통점</strong> 을 갖는다.</p>
<ul>
<li>객체 리터럴</li>
<li>Object 생성자 함수</li>
<li>생성자 함수</li>
<li>Object.create 메소드</li>
<li>클래스 (ES6)</li>
</ul>
<h3 id="객체-리터럴에-의해-생성된-객체의-프로토타입"><a href="#객체-리터럴에-의해-생성된-객체의-프로토타입" class="headerlink" title="객체 리터럴에 의해 생성된 객체의 프로토타입"></a>객체 리터럴에 의해 생성된 객체의 프로토타입</h3><p>자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때, 추상 연산 <code>ObjectCreate</code>를 호출한다. 이때 추상 연산 <code>ObjectCreate</code>에 전달되는 프로토타입은 <code>Object.prototype</code>이다. 객체 리터럴에 의해 생성되는 객체의 프로토타입은 <code>Object.prototype</code>이다.</p>
<h3 id="Object-생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#Object-생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="Object 생성자 함수에 의해 생성된 객체의 프로토타입"></a>Object 생성자 함수에 의해 생성된 객체의 프로토타입</h3><p>명시적으로 <code>Object</code> 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. <code>Object</code> 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 <code>ObjectCreate</code>를 호출한다. 이때 추상 연산 <code>ObjectCreate</code>에 전달되는 프로토타입은 <code>Object.prototype</code>이다. <code>Object</code> 생성자 함수에 의해 생성되는 객체의 프로토타입은 <code>Object.prototype</code>이다.</p>
<blockquote>
<p><strong>객체 리터럴과 <code>Object</code> 생성자 함수에 의한 객체 생성 방식의 차이</strong>: 프로퍼티를 추가하는 방식<br><strong>객체 리터럴 방식</strong>: 객체 리터럴 내부에 프로퍼티를 추가<br><strong>Object 생성자 함수 방식</strong>: 일단 빈객체를 생성한 이후 프로퍼티를 추가</p>
</blockquote>
<h3 id="생성자-함수에-의해-생성된-객체의-프로토타입"><a href="#생성자-함수에-의해-생성된-객체의-프로토타입" class="headerlink" title="생성자 함수에 의해 생성된 객체의 프로토타입"></a>생성자 함수에 의해 생성된 객체의 프로토타입</h3><p><code>new</code> 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 <code>ObjectCreate</code>를 호출한다. 이때 추상 연산 <code>ObjectCreate</code>에 전달되는 프로토타입은 생성자 함수의 <code>prototype</code> 프로퍼티에 바인딩되어 있는 객체이다. 즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 <code>prototype</code> 프로퍼티에 바인딩되어 있는 객체이다.</p>
<h2 id="프로토타입-체인"><a href="#프로토타입-체인" class="headerlink" title="프로토타입 체인"></a>프로토타입 체인</h2><p>자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 <u><code>__proto__</code> 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.</u> 이것을 <strong>프로토타입 체인</strong> 이라 한다. 프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다.</p>
<h3 id="프로토-타입의-종점-End-of-prototype-chain"><a href="#프로토-타입의-종점-End-of-prototype-chain" class="headerlink" title="프로토 타입의 종점(End of prototype chain)"></a><strong>프로토 타입의 종점</strong>(End of prototype chain)</h3><p>프로토타입 체인의 최상위에 위치하는 객체는 언제나 <code>Object.prototype</code>이다. 따라서 모든 객체는 <code>Object.prototype</code>을 상속받는다.  <code>Object.prototype</code>의 프로토타입, 즉 <code>[[Prototype]]</code> 내부 슬롯의 값은 <code>null</code>이다.</p>
<h2 id="캡슐화"><a href="#캡슐화" class="headerlink" title="캡슐화"></a>캡슐화</h2><blockquote>
<p><strong>캡슐화(encapsulation)</strong><br>정보의 일부를 외부에 감추어 은닉(정보 은닉(information hiding))하는 것</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 프로토타입 메소드</span></span><br><span class="line">  Person.prototype.sayHello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수를 반환</span></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>외부에 공개할 필요가 없는 구현의 일부를 외부에 노출되지 않도록 감추어 적절치 못한 접근으로부터 정보를 보호하고 객체간의 상호 의존성, 즉 결합도를 낮추는 효과가 있다. <strong>자바스크립트는 <code>public</code>, <code>private</code>, <code>protected</code>와 같은 접근 제한자를 제공하지 않는다.</strong></p>
<p>클로저 참고.</p>
<h2 id="오버라이딩과-프로퍼티-쉐도잉"><a href="#오버라이딩과-프로퍼티-쉐도잉" class="headerlink" title="오버라이딩과 프로퍼티 쉐도잉"></a>오버라이딩과 프로퍼티 쉐도잉</h2><ul>
<li>하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다.</li>
<li>하위 객체를 통해 프로토타입에 <code>get</code> 액세스는 허용되나 <code>set</code> 액세스는 허용되지 않는다.</li>
</ul>
<blockquote>
<p><strong>프로토타입 프로퍼티</strong>: 프로토타입이 소유한 프로퍼티 (메소드 포함)<br><strong>인스턴스 프로퍼티</strong>: 인스턴스가 소유한 프로퍼티</p>
</blockquote>
<blockquote>
<p><strong>오버라이딩(Overriding)</strong><br>상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용하는 방식</p>
</blockquote>
<blockquote>
<p><strong>오버로딩(Overloading)</strong><br>함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메소드를 구현하고 매개변수에 의해 메소드를 구별하여 호출하는 방식이다. 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수는 있다.</p>
</blockquote>
<h2 id="프로토타입의-교체"><a href="#프로토타입의-교체" class="headerlink" title="프로토타입의 교체"></a>프로토타입의 교체</h2><p>프로토타입은 <strong>다른 임의의 객체로 변경</strong> 할 수 있다. 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 의미이다. <strong><u>생성자 함수 또는 인스턴스에 의해 교체</u></strong> 할 수 있다.</p>
<blockquote>
<p>프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 꽤나 번거롭다. 하지만 ES6에서 도입된 클래스를 사용하면 간편하고 직관적으로 상속 관계를 구현할 수 있다.</p>
</blockquote>
<h3 id="생성자-함수에-의한-프로토타입의-교체"><a href="#생성자-함수에-의한-프로토타입의-교체" class="headerlink" title="생성자 함수에 의한 프로토타입의 교체"></a>생성자 함수에 의한 프로토타입의 교체</h3><ul>
<li>프로토타입을 교체하면 <code>constructor</code> 프로퍼티와 생성자 함수 간의 링크가 파괴된다.</li>
<li>프로토타입으로 교체한 객체 리터럴에는 <code>constructor</code> 프로퍼티가 없다. 따라서 me 객체의 생성자 함수를 검색하면 <code>Person</code>이 아닌 <code>Object</code>가 나온다.</li>
<li>프로토타입으로 교체한 객체 리터럴에 <code>constructor</code> 프로퍼티를 추가하여 프로토타입의 <code>constructor</code> 프로퍼티를 되살린다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체</span></span><br><span class="line">  Person.prototype = &#123;</span><br><span class="line">    <span class="comment">// constructor 프로퍼티와 생성자 함수 간의 링크 설정</span></span><br><span class="line">    <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">    <span class="title">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor 프로퍼티가 생성자 함수를 가리킨다.</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === <span class="built_in">Object</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>


<h3 id="인스턴스에-의한-프로토타입의-교체"><a href="#인스턴스에-의한-프로토타입의-교체" class="headerlink" title="인스턴스에 의한 프로토타입의 교체"></a>인스턴스에 의한 프로토타입의 교체</h3><ul>
<li>인스턴스의 <code>__proto__</code> 접근자 프로퍼티(또는 <code>Object.setPrototypeOf</code> 메소드)를 통해 프로토타입을 교체할 수 있다.</li>
<li>생성자 함수의 <code>prototype</code> 프로퍼티에 다른 임의의 객체를 바인딩하는 것은 미래에 생성할 인스턴스의 프로토타입을 교체하는 것을 의미한다. <code>__proto__</code> 접근자 프로퍼티를 통해 프로토타입을 교체하는 것은 이미 생성된 객체의 프로토타입을 교체하는 것.</li>
<li>인스턴스에 의한 프로토타입 교체도 <code>constructor</code> 프로퍼티와 생성자 함수 간의 연결을 파괴한다.</li>
<li>프로토타입으로 교체한 객체 리터럴에 <code>constructor</code> 프로퍼티를 추가하고 생성자 함수의 <code>prototype</code> 프로퍼티를 재설정한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Kim&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로토타입으로 교체할 객체</span></span><br><span class="line"><span class="keyword">const</span> parent = &#123;</span><br><span class="line">  <span class="comment">// constructor 프로퍼티와 생성자 함수 간의 링크 설정</span></span><br><span class="line">  <span class="title">constructor</span>: <span class="title">Person</span>,</span><br><span class="line">  <span class="title">sayHello</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 링크 설정</span></span><br><span class="line">Person.prototype = parent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// me 객체의 프로토타입을 parent 객체로 교체한다.</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(me, parent);</span><br><span class="line"><span class="comment">// 위 코드는 아래의 코드와 동일하게 동작한다.</span></span><br><span class="line"><span class="comment">// me.__proto__ = parent;</span></span><br><span class="line"></span><br><span class="line">me.sayHello(); <span class="comment">// Hi! My name is Kim</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor 프로퍼티가 생성자 함수를 가리킨다.</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(me.constructor === <span class="built_in">Object</span>); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리킨다.</span></span><br><span class="line"><span class="built_in">console</span>.log(Person.prototype === <span class="built_in">Object</span>.getPrototypeOf(me)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>


<h3 id="생성자-함수에-의한-프로토타입-교체와-인스턴스에-의한-프로토타입-교체의-차이"><a href="#생성자-함수에-의한-프로토타입-교체와-인스턴스에-의한-프로토타입-교체의-차이" class="headerlink" title="생성자 함수에 의한 프로토타입 교체와 인스턴스에 의한 프로토타입 교체의 차이"></a>생성자 함수에 의한 프로토타입 교체와 인스턴스에 의한 프로토타입 교체의 차이</h3><img src="http://mjae404.github.io/images/prototype.jpg" alt="프로토타입 교체 방식에 의해 발생하는 차이">


<h2 id="instanceof-연산자"><a href="#instanceof-연산자" class="headerlink" title="instanceof 연산자"></a>instanceof 연산자</h2><ul>
<li><code>instanceof</code> 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다.</li>
<li>우변의 피연산자가 함수가 아닌 경우, <code>TypeError</code>가 발생한다.</li>
<li><code>instanceof</code> 연산자는 프로토타입의 <code>constructor</code> 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라 프로토타입 체인 상에 존재하는 프로토타입에 영향을 받는다.</li>
<li><code>instanceof</code> 연산자는 좌변 피연산자의 프로토타입 체인 상에 우변의 피연산자, 즉 생성자 함수의 <code>prototype</code> 프로퍼티에 바인딩된 객체가 존재하는지 검색한다.</li>
<li>생성자 함수에 의해 프로토타입이 교체되어 <code>constructor</code> 프로퍼티와 생성자 함수 간의 링크가 파괴된 경우, 생성자 함수의 <code>prototype</code> 프로퍼티와 프로토타입 간의 링크는 파괴되지 않으므로 <code>instanceof</code>는 아무런 영향을 받지 않는다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">객체 <span class="keyword">instanceof</span> 생성자 함수</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Person = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체</span></span><br><span class="line">  Person.prototype = &#123;</span><br><span class="line">    <span class="function"><span class="title">sayHello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Hi! My name is <span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Person;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> me = <span class="keyword">new</span> Person(<span class="string">&#x27;Lee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// constructor 프로퍼티와 생성자 함수 간의 링크가 파괴되어도</span></span><br><span class="line"><span class="comment">// instanceof는 아무런 영향을 받지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(me <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="직접-상속"><a href="#직접-상속" class="headerlink" title="직접 상속"></a>직접 상속</h2><h3 id="Object-create에-의한-직접-상속"><a href="#Object-create에-의한-직접-상속" class="headerlink" title="Object.create에 의한 직접 상속"></a>Object.create에 의한 직접 상속</h3><p><code>Object.create</code> 메소드는 명시적으로 프로토타입을 지정하여 새로운 객체를 생성한다. <code>Object.create</code> 메소드도 다른 객체 생성 방식과 마찬가지로 추상 연산 <code>ObjectCreate</code>를 호출한다.</p>
<blockquote>
<p> 직접 상속은 위와 같이 여러 장점이 있다. 하지만 두번째 인자로 프로퍼티를 정의하는 것은 번거롭다.</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체를 생성하여 반환한다.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> <span class="variable">prototype</span></span> - 생성할 객체의 프로토타입으로 지정할 객체</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Object&#125;</span> </span>[propertiesObject] - 생성할 객체의 프로퍼티를 갖는 객체</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns <span class="type">&#123;Object&#125;</span> </span>지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Object</span>.create(prototype[, propertiesObject])</span><br></pre></td></tr></table></figure>


<h3 id="객체-리터럴-내부에서-proto-에-의한-직접-상속"><a href="#객체-리터럴-내부에서-proto-에-의한-직접-상속" class="headerlink" title="객체 리터럴 내부에서 __proto__에 의한 직접 상속"></a>객체 리터럴 내부에서 __proto__에 의한 직접 상속</h3><p>ES6에서는 객체 리터럴 내부에서 <strong><code>proto</code></strong> 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myProto = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  y: <span class="number">20</span>,</span><br><span class="line">  <span class="comment">// 객체를 직접 상속받는다.</span></span><br><span class="line">  <span class="comment">// obj → myProto → Object.prototype → null</span></span><br><span class="line">  __proto__: myProto</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 위 코드는 아래와 동일하다.</span></span><br><span class="line"><span class="comment">// const obj = Object.create(myProto, &#123; y: &#123; value: 20 &#125; &#125;);</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.x, obj.y); <span class="comment">// 10 20</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(obj) === myProto); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="정적-프로퍼티-메소드"><a href="#정적-프로퍼티-메소드" class="headerlink" title="정적 프로퍼티/메소드"></a>정적 프로퍼티/메소드</h2><blockquote>
<p><strong>정적(static) 프로퍼티/메소드</strong>: 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드</p>
</blockquote>
<ul>
<li>생성자 함수는 객체이므로 자신의 프로퍼티/메소드를 소유할 수 있다. <strong>생성자 함수 객체가 소유한 프로퍼티/메소드</strong> 를 정적 프로퍼티/메소드라고 부른다.</li>
<li>생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.</li>
<li>모든 객체는 생성자 함수에 의해 생성된다.</li>
<li>생성자 함수가 생성한 인스턴스는 자신의 프로토타입 체인에 속한 객체의 프로퍼티/메소드에 접근할 수 있다.</li>
<li>정적 프로퍼티/메소드는 인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티/메소드가 아니므로 인스턴스로 접근할 수 없다.</li>
<li>프로토타입 메소드를 호출하려면 인스턴스를 생성해야 하지만 정적 메소드는 인스턴스를 생성하지 않아도 호출할 수 있다.</li>
</ul>
<h2 id="프로퍼티-존재-확인"><a href="#프로퍼티-존재-확인" class="headerlink" title="프로퍼티 존재 확인"></a>프로퍼티 존재 확인</h2><ul>
<li><code>in</code> 연산자는 객체 내에 프로퍼티가 존재하는지 여부를 확인한다.</li>
<li><code>in</code> 연산자는 확인 대상 객체의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인한다.<ul>
<li>in 연산자가 <code>person</code> 객체가 속한 프로토타입 체인 상에 존재하는 모든 프로토타입에서 <code>toString</code> 프로퍼티를 검색했기 때문</li>
<li><code>toString</code>은 <code>Object.prototype</code>의 메소드이다.</li>
<li><code>Object.prototype.hasOwnProperty</code> 메소드를 사용해도 객체의 프로퍼티의 존재 여부를 확인 가능. 객체 고유의 프로퍼티인 경우에만 <code>true</code>를 반환하고 상속받은 프로토타입의 프로퍼티인 경우 <code>false</code>를 반환한다.</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prop: 프로퍼티 키를 나타내는 문자열</span></span><br><span class="line"><span class="comment"> * object: 객체로 평가되는 표현식</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">prop <span class="keyword">in</span> object</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Lee&#x27;</span>,</span><br><span class="line">  address: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// person 객체에 name 프로퍼티가 존재한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> person);    <span class="comment">// true</span></span><br><span class="line"><span class="comment">// person 객체에 age 프로퍼티가 존재하지 않는다.</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;age&#x27;</span> <span class="keyword">in</span> person);     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="프로퍼티-열거"><a href="#프로퍼티-열거" class="headerlink" title="프로퍼티 열거"></a>프로퍼티 열거</h2><h3 id="for…in-문"><a href="#for…in-문" class="headerlink" title="for…in 문"></a>for…in 문</h3><p>객체의 프로토타입 체인 상에 존재하는 모든 프로토타입의 프로퍼티 중에서 프로퍼티 어트리뷰트 <code>[[Enumerable]]</code>의 값이 <code>ture</code>인 프로퍼티를 순회하며 열거(enumeration)한다.</p>
<ul>
<li>프로퍼티를 열거할 때 순서를 보장하지 않는다.</li>
<li>객체의 프로퍼티 개수만큼 반복하며 <code>for…in</code> 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당한다.</li>
<li><strong>상속받은 프로토타입의 프로퍼티까지 열거</strong> 한다.</li>
<li><code>Object.prototype.string</code> 프로퍼티의 프로퍼티 어트리뷰트 <code>[[Enumerable]]</code>의 값이 <code>false</code>인 경우 <code>Object.prototype</code>의 프로퍼티가 열거되지 않는다.</li>
<li>프로퍼티 키가 심볼인 프로퍼티는 열거하지 않는다.</li>
<li>상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티 만을 열거하려면 <strong><code>Object.prototype.hasOwnProperty</code> 메소드를 사용하여 객체 자신의 프로퍼티인지 확인</strong> 해야 한다.</li>
<li>배열에는 <code>for…in</code> 문보다 일반적인 <code>for</code> 문이나 <code>for…of</code> 문 또는 <code>Array.prototype.forEach</code> 메소드를 사용하기를 권장한다.</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (변수선언문 <span class="keyword">in</span> 객체) &#123; … &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;Kim&#x27;</span>,</span><br><span class="line">  address: <span class="string">&#x27;Seoul&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> person) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(prop + <span class="string">&#x27;: &#x27;</span> + person[prop]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// name: Kim</span></span><br><span class="line"><span class="comment">// address: Seoul</span></span><br></pre></td></tr></table></figure>

<h3 id="Object-keys-values-entries-메소드"><a href="#Object-keys-values-entries-메소드" class="headerlink" title="Object.keys/values/entries 메소드"></a>Object.keys/values/entries 메소드</h3><ul>
<li><strong>Object.keys</strong>: 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.</li>
<li>ES8에서 도입된 <strong>Object.values</strong>: 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환</li>
<li>ES8에서 도입된 <strong>Object.entries</strong>: 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환</li>
</ul>
<hr>
<blockquote>
<p><strong>REFERENCE</strong><br><a target="_blank" rel="noopener" href="https://poiemaweb.com/">https://poiemaweb.com</a></p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    <footer class="article-footer">
      <a data-url="http://mjae404.github.io/2020/09/20/js-prototype/" data-id="cm4wfoffm00aqjp0a9vdr58at"
        class="article-share-link">share</a>
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JavaScript/" rel="tag">JavaScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/prototype/" rel="tag">prototype</a></li></ul>

    </footer>

  </div>

  
  
  <nav class="article-nav">
    
      <a href="/2020/09/21/js-this/" class="article-nav-link">
        <strong class="article-nav-caption">next</strong>
        <div class="article-nav-title">
          
            JS this
          
        </div>
      </a>
    
    
      <a href="/2020/09/19/js-constructor/" class="article-nav-link">
        <strong class="article-nav-caption">prev</strong>
        <div class="article-nav-title">JS 생성자 함수에 의한 객체 생성</div>
      </a>
    
  </nav>


  

  

  
  
  

</article>
</section>
      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020-2025
        404 Not Found
      </li>
      <li>
        
          Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
  </div>
</footer>
    <div class="to_top">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>
      </div>
    </div>
    
      <aside class="sidebar">
        
        <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="404 Not Found"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HOME</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/about">ABOUT</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">ARCHIVES</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">CATEGORY</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">TAGS</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="검색">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
      </aside>
      <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i></p>
  <div class="reward-box">
    
    
  </div>
</div>
      
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>


  
<script src="/fancybox/jquery.fancybox.min.js"></script>





<script>
  var ayerConfig = {
    mathjax: false
  }
</script>


<script src="/js/ayer.js"></script>


<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>
  
  

  </div>
</body>

</html>